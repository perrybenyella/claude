# Architectural Patterns

This document describes the recurring architectural patterns, design decisions, and conventions used throughout the Office Chore Manager codebase.

## State Management Pattern

### Zustand Store Architecture

The application uses a centralized Zustand store pattern with all state in a single store (`src/store/useAppStore.ts`).

**Key Characteristics:**
- Single source of truth for all application state
- Actions co-located with state in the same store
- Selector-based access from components
- No prop drilling required

**Store Structure:**
```typescript
interface AppState {
  // State properties
  teamMembers: TeamMember[];
  chores: Chore[];

  // Actions (functions that modify state)
  addTeamMember: (name: string) => void;
  removeTeamMember: (id: string) => void;

  // Computed/helper methods
  getChoresForDate: (date: Date) => Chore[];
}
```

**Examples in Code:**
- Store definition: `src/store/useAppStore.ts:44-147`
- Action with immutable update: `src/store/useAppStore.ts:52-61`
- Computed helper: `src/store/useAppStore.ts:113-116`

### Component-Store Interaction

Components access state using selector functions to minimize re-renders:

```typescript
// Extract only what's needed
const teamMembers = useAppStore(state => state.teamMembers);
const addTeamMember = useAppStore(state => state.addTeamMember);
```

**Examples:**
- `src/components/Team/TeamMemberForm.tsx:6` - Selecting single action
- `src/components/Chores/ChoreForm.tsx:16-17` - Selecting multiple state slices
- `src/App.tsx:11-12` - Root component selecting state

## Component Organization

### Feature-Based Structure

Components are organized by feature/domain rather than by type:

```
components/
├── Calendar/     # All calendar-related components
├── Chores/       # All chore-related components
└── Team/         # All team-related components
```

This keeps related functionality together and makes the codebase easier to navigate.

**Pattern**: When adding a new feature, create a new folder under `components/` with all related components.

### Component Composition

Components are kept small and composed together to build larger UIs.

**Example**: Calendar feature composition
```typescript
CalendarView           // Container
  ├── CalendarHeader   // Navigation and month display
  └── MonthView        // Grid of days
      └── DayCell      // Individual day (used 28-31 times)
```

**Code References:**
- `src/components/Calendar/CalendarView.tsx:4-11` - Simple composition component
- `src/App.tsx:27-54` - Top-level composition with layout

### Controlled Components

All form inputs use the controlled component pattern with local state.

**Pattern:**
1. Create state for each input: `const [name, setName] = useState('')`
2. Bind to input: `value={name}` and `onChange={(e) => setName(e.target.value)}`
3. On submit, call store action with state values

**Examples:**
- `src/components/Team/TeamMemberForm.tsx:5-31` - Simple form with single input
- `src/components/Chores/ChoreForm.tsx:6-82` - Complex form with multiple inputs and conditional rendering

## Type System Patterns

### Centralized Type Definitions

All shared types are defined in `src/types/index.ts`. This provides:
- Single source of truth for data structures
- Easy discoverability (one file to check)
- Prevents duplicate/conflicting type definitions

**Pattern**: Export interfaces for domain entities, plus separate "Input" types for creation:

```typescript
export interface Chore {
  id: string;           // Generated by store
  title: string;
  createdAt: Date;      // Added by store
  // ... other fields
}

export interface ChoreInput {
  title: string;        // User provides
  // ... only fields user provides
}
```

**Code Reference:** `src/types/index.ts:1-38`

### Type Safety Through Interfaces

Types use explicit interfaces rather than type aliases for better IDE support and error messages.

**Pattern**: Prefer `interface` over `type` for object shapes:
- `interface TeamMember { ... }` ✓
- `type TeamMember = { ... }` ✗ (less readable in errors)

## Data Flow Pattern

### Unidirectional Data Flow

```
User Action → Store Action → State Update → Component Re-render
```

**Never**: Directly modify state in components
**Always**: Call store actions that return new state

**Example Flow:**
1. User submits form: `src/components/Team/TeamMemberForm.tsx:8-14`
2. Calls store action: `addTeamMember(name)`
3. Store creates new state: `src/store/useAppStore.ts:52-61`
4. Components re-render with new state

### Immutable Updates

All state updates use immutable patterns (spread operator, array methods that return new arrays).

**Examples:**
- Adding item: `[...state.items, newItem]` - `src/store/useAppStore.ts:59`
- Removing item: `state.items.filter(item => item.id !== id)` - `src/store/useAppStore.ts:65`
- Updating item: `state.items.map(item => item.id === id ? { ...item, ...updates } : item)` - `src/store/useAppStore.ts:95-99`

**Pattern**: Never use `push()`, `splice()`, direct property assignment on state objects.

## Utility Function Patterns

### Pure Functions

Utility functions are pure (no side effects, deterministic output):

```typescript
export function doesChoreOccurOnDate(chore: Chore, date: Date): boolean {
  // Only depends on inputs, no external state
  // Always returns same result for same inputs
}
```

**Code Reference:** `src/utils/recurrenceUtils.ts:10-25`

### Function Organization

- **Date utilities** (`src/utils/dateUtils.ts`): Generic date operations
- **Domain utilities** (`src/utils/recurrenceUtils.ts`): Business logic specific to chores

**Pattern**:
- Put generic/reusable functions in utility modules
- Keep domain-specific logic in domain utility files
- Export named functions (not default exports) for clarity

## ID Generation Pattern

### Client-Side ID Generation

Since there's no backend, IDs are generated client-side using timestamp + random string:

```typescript
const generateId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};
```

**Code Reference:** `src/store/useAppStore.ts:40-42`

**Properties:**
- Unique within session (timestamp + random)
- Sortable by creation time (timestamp prefix)
- String type (works with any backend later)

**Pattern**: All entities (TeamMember, Chore) use this same ID generation approach.

## Component Patterns

### Form Submission Pattern

All forms follow this pattern:

1. Prevent default: `e.preventDefault()`
2. Validate inputs (show alert if invalid)
3. Transform form state to domain type
4. Call store action
5. Reset form state

**Example:** `src/components/Chores/ChoreForm.tsx:37-82`

### Conditional Rendering

The codebase uses short-circuit evaluation for conditional rendering:

```typescript
{isRecurring && (
  <div>Recurring options...</div>
)}
```

**Examples:**
- `src/components/Chores/ChoreForm.tsx:137-144` - Show date picker for one-time
- `src/components/Chores/ChoreForm.tsx:157-170` - Show day selector for recurring

**Pattern**: Use `&&` for showing/hiding, ternary for A vs B choices.

## Styling Patterns

### CSS Class Naming

The codebase uses descriptive, hyphenated class names:

```css
.team-member-form
.btn-add-member
.chore-form
.calendar-view
```

**Pattern**: `{feature}-{element}-{modifier}` or `{element}-{modifier}`

### Component-Scoped Styles

Each major component typically has related styles in `src/styles/index.css`.

**Pattern**: Group related styles together in the stylesheet, use class names that match component names.

## Error Handling Patterns

### Form Validation

Simple validations use `alert()` for immediate user feedback:

```typescript
if (!title.trim()) {
  alert('Please enter a chore title');
  return;
}
```

**Code Reference:** `src/components/Chores/ChoreForm.tsx:40-43`

**Pattern**: Check validity, alert user, early return to prevent submission.

### Data Guard Clauses

Guard clauses early-exit functions when conditions aren't met:

```typescript
if (!chore.recurrence) {
  return chore.date ? isSameDay(chore.date, date) : false;
}
// Continue with recurrence logic...
```

**Code Reference:** `src/utils/recurrenceUtils.ts:12-14`

**Pattern**: Handle simple/edge cases first, then handle complex logic.

## State Coupling Patterns

### Cascading Updates

When removing a team member, automatically unassign their chores:

```typescript
removeTeamMember: (id: string) => {
  set(state => ({
    teamMembers: state.teamMembers.filter(member => member.id !== id),
    chores: state.chores.map(chore =>
      chore.assignedTo === id ? { ...chore, assignedTo: null } : chore
    )
  }));
}
```

**Code Reference:** `src/store/useAppStore.ts:63-73`

**Pattern**: When deleting an entity, clean up all references to it in the same action.

## Date Handling Patterns

### Date Library Usage

All date operations use `date-fns` library for consistency and reliability:

```typescript
import { isSameDay, startOfMonth, isWithinInterval } from 'date-fns';
```

**Pattern**:
- Never use native Date methods for calculations
- Always use date-fns for comparisons, formatting, arithmetic
- Import only functions you need (tree-shaking)

**Examples:**
- `src/utils/recurrenceUtils.ts:1` - Import pattern
- `src/store/useAppStore.ts:4` - Multiple date-fns imports

### Date Storage

Dates are stored as `Date` objects in state, not as strings or timestamps.

**Why**:
- Type safety (TypeScript enforces Date type)
- Works directly with date-fns
- No parsing errors

**Form Date Handling:**
Forms use string inputs (`<input type="date">`) but convert to Date objects before storing:

```typescript
date: new Date(oneTimeDate)  // Convert string to Date
```

**Code Reference:** `src/components/Chores/ChoreForm.tsx:71`

## Recurrence Logic Pattern

### Day-of-Week Representation

Days of week use JavaScript's convention: 0 = Sunday, 6 = Saturday

```typescript
daysOfWeek: number[];  // [0, 2, 4] = Sunday, Tuesday, Thursday
```

**Pattern**: Always use numeric representation, convert to labels only in UI.

**Code Reference:**
- Type definition: `src/types/index.ts:11`
- UI labels: `src/components/Chores/ChoreForm.tsx:19-27`
- Logic: `src/utils/recurrenceUtils.ts:17`

### Recurrence Checking

To check if a chore occurs on a date:
1. Check if it's within date range (start/end)
2. Check if day of week matches pattern

**Code Reference:** `src/utils/recurrenceUtils.ts:10-25`

## Computed Values Pattern

### Store Getters

Computed values that depend on state are implemented as getter functions in the store:

```typescript
getChoresForDate: (date: Date) => {
  const state = get();
  return filterChoresForDate(state.chores, date);
}
```

**Code Reference:** `src/store/useAppStore.ts:113-116`

**Why**:
- Always returns fresh data based on current state
- Can be called with parameters
- Doesn't need separate derived state

**Pattern**: Use getters for derived data that needs parameters. For simple derived values without params, consider derived atoms/selectors.

## Code Organization Principles

### Import Ordering

Imports follow this order:
1. React/third-party libraries
2. Store/state imports
3. Types
4. Components
5. Utilities
6. Styles

**Example:** `src/App.tsx:1-8`

### Export Patterns

**Pattern**:
- Components: Named exports (`export function ComponentName()`)
- Types: Named exports (`export interface TypeName`)
- Utilities: Named exports (`export function utilityName()`)
- Constants: Named exports (`export const CONSTANT_NAME`)

**Why**: Named exports are more refactor-friendly and explicit.

## Performance Considerations

### Selector Granularity

Components select only the state they need to minimize re-renders:

```typescript
// Good: Only re-renders when teamMembers changes
const teamMembers = useAppStore(state => state.teamMembers);

// Avoid: Re-renders on ANY state change
const state = useAppStore();
```

**Examples:**
- Minimal selection: `src/components/Team/TeamMemberForm.tsx:6`
- Multiple specific selections: `src/components/Chores/ChoreForm.tsx:16-17`

### Memoization

The codebase currently doesn't use memoization (no `useMemo`, `useCallback`, `memo`) because:
- Components are small and fast
- State updates are infrequent (user actions only)
- No expensive computations

**Pattern**: Only add memoization if profiling shows performance issues.

## Convention Summary

### Naming Conventions
- **Components**: PascalCase (`TeamMemberForm`)
- **Functions/variables**: camelCase (`addTeamMember`, `teamMembers`)
- **Types/Interfaces**: PascalCase (`TeamMember`, `ChoreInput`)
- **Constants**: UPPER_SNAKE_CASE (`DAYS_OF_WEEK`)
- **CSS classes**: kebab-case (`team-member-form`, `btn-add-member`)

### File Naming
- **Components**: PascalCase matching component name (`TeamMemberForm.tsx`)
- **Utilities**: camelCase (`recurrenceUtils.ts`)
- **Types**: lowercase (`index.ts` in types folder)
- **Styles**: lowercase (`index.css`)

### Function Conventions
- **Actions**: Verb prefix (`addTeamMember`, `removeChore`, `setSelectedDate`)
- **Predicates**: Question format (`doesChoreOccurOnDate`)
- **Getters**: `get` prefix (`getChoresForDate`)

## Testing Considerations

While there are currently no tests, the architecture supports testing:

**Testable patterns:**
- Pure utility functions (no dependencies)
- Store actions (can be tested in isolation)
- Components using selectors (can mock store)

**Pattern for adding tests:**
1. Test utilities first (pure functions, easy to test)
2. Test store actions (next easiest)
3. Test components with mocked store (more setup needed)
